<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Video Annotator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@eyepop.ai/javascript-sdk"></script>
</head>

<body class="overflow-x-hidden">

    <!-- A spinning loading animation -->
    <div id="loading"
        class="position-absolute w-100 h-100 d-flex align-items-center justify-content-center bg-black flex-column"
        style="z-index: 1000;">
        <div id="loadingText" class="text-white text-start p-5">Loading Pop...</div>
        <div class="spinner-border text-light align-self-center" role="status">

            <span class="visually-hidden">Loading...</span>

        </div>
    </div>

    <div class="d-flex flex-column w-100 min-vw-100 h-100 min-vh-100">

        <header class="vw-100 z-3 min-vw-100" style="height:5rem;">
            <div class="d-flex align-items-center w-100 justify-content-between text-center">
                <a href="1_upload_image.html">
                    <img src="css/images/eyepop-logo.svg" alt="EyePop.ai Logo" class="" style="height: 70px;">
                </a>
                <h1 class="p-2 text-center text-blac">Batch Image / Video Tester</h1>
                <h6 id="popConfigName" class="text-center text-blac"></h6>
            </div>
        </header>

        <div class="d-flex flex-column bg-white flex-row justify-content-center gap-5 z-3">


            <div class="d-flex flex-column justify-content-center gap-3 w-50 m-5 ">
                <!-- FORM UPLOAD ELEMENT: Centered, Full Width Row -->
                <div class="row justify-content-center">

                    <h4 class="text-black border-2 border-dark p-2"> 1. Select a folder:</h4>

                    <form>
                        <input type="file" class="form-control" id="file_upload">
                    </form>

                    <h4 class="text-black border-2 border-dark p-2"> 2. Click Play. </h4>
                    <form class="d-flex">

                        <button id="togglePlay" class="btn btn-primary" type="button">Pause</button>

                        <input type="number" class="form-control w-50" placeholder="Seconds to skip"
                            aria-describedby="basic-addon2" id="framesToSkip">

                        <button id="saveButton" class="btn btn-info" type="button">save result</button>

                        <div class="form-check d-flex justify-content-center align-content-center  text-blac">
                            <div class="form-check d-flex justify-content-center align-self-center">
                                <input class="form-check-input" type="radio" name="positiveNegativeRadio"
                                    id="positiveRadio" value="positive">
                                <label class="form-check-label" for="positiveRadio">
                                    fp
                                </label>
                            </div>

                            <div class="form-check d-flex justify-content-center  align-self-center">
                                <input class="form-check-input" type="radio" name="positiveNegativeRadio"
                                    id="negativeRadio" value="negative">
                                <label class="form-check-label" for="negativeRadio">
                                    fn
                                </label>
                            </div>

                            <div class="form-check d-flex justify-content-center  align-self-center">
                                <input class="form-check-input" type="radio" name="positiveNegativeRadio"
                                    id="positiveNegativeRadio" value="negative">
                                <label class="form-check-label" for="positiveNegativeRadio">
                                    fpn
                                </label>
                            </div>
                        </div>

                    </form>
                </div>

                <div class="gap-1 w-100">
                    <span class="text-info">name: </span>
                    <span id="mediaName" class="text-blac">Video</span>
                    <span class="text-info">( file #: </span>
                    <span id="mediaIndex" class="text-blac">0</span>
                    <span class=""> / </span>
                    <span id="totalFiles" class="text-blac">0</span>
                    <span class="text-info"> ) </span>
                    <span class="text-info">frame #: </span>
                    <span id="mediaTime" class="text-blac">0</span>
                </div>

                <video id="myLocalVideo" playsinline controls muted class="position-absolute"
                    style="width:1px;height:1px;"></video>
                <video id="videoCapture" class="position-absolute z-n1" class="position-absolute"
                    style="width: 1px; height: 1px; left:0"></video>

            </div>

        </div>
        <div class="d-flex flex-column text-center bg-black">

            <canvas id="mobilecanvas" class="bg-gradient object-fit-contain justify-content-center align-self-center"
                style="width: 640px; height: 480px;" width="1920" height="1080"></canvas>
        </div>

    </div>

    <script src="./config.js"></script>

    <script type="module">

        import FFmpeg from '@ffmpeg/ffmpeg';

        var fileInput = document.getElementById('file_upload');
        const postButton = document.getElementById('btnPost');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');

        const captureCanvas = document.createElement("canvas");
        const captureContext = captureCanvas.getContext("2d");
        const captureVideo = document.getElementById("videoCapture");

        const mobilecanvas = document.getElementById("mobilecanvas");
        const mobileCanvasContext = mobilecanvas.getContext("2d");

        const framesToSkip = document.getElementById("framesToSkip");
        const playPause = document.getElementById("playPause");

        const togglePlay = document.getElementById("togglePlay");
        const saveButton = document.getElementById("saveButton");


        mobileCanvasContext.imageSmoothingEnabled = true;
        mobileCanvasContext.imageSmoothingQuality = "high";

        const recordingCanvas = document.createElement("canvas");
        const recordingCtx = recordingCanvas.getContext("2d");
        recordingCtx.imageSmoothingEnabled = true;
        recordingCtx.imageSmoothingQuality = "high";
        recordingCanvas.width = 1920;
        recordingCanvas.height = 1080;

        var cached_data = [];

        var chunks = [];

        let ffmpegTool = null;

        async function createVideoFromImages(imageBlobs)
        {
            if (ffmpegTool === null)
            {
                ffmpegTool = await FFmpeg({
                    logger: ({ message }) =>
                    {
                        console.log(message);
                    },
                });
            }

            // Convert blobs to array buffers and write them to the ffmpeg filesystem
            for (let i = 0; i < imageBlobs.length; i++)
            {
                let buffer = await imageBlobs[ i ].arrayBuffer();
                await ffmpegTool.writeFile('frame' + ('000' + i).slice(-3) + '.png', new Uint8Array(buffer));
            }

            await ffmpegTool.exec([ '-framerate', '30', '-i', 'frame%03d.png', '-c:v', 'libx264', '-r', '30', '-pix_fmt', 'yuv420p', 'out.mp4' ]);

            let outputData = await ffmpegTool.readFile('out.mp4');

            console.log('ffmpegTool result', result);

            let outputBlob = new Blob([ outputData.data.buffer ], { type: 'video/mp4' });

            // Create a URL for the Blob
            let url = URL.createObjectURL(outputBlob);

            // Create a download link and click it
            let a = document.createElement('a');
            a.href = url;
            a.download = 'output.mp4';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }


        var positiveNegativePrefix = "fpn_";


        // the canvases we draw to for saving to file
        let videoCanvas = document.createElement('canvas');
        let isVideo = false;
        let image = null;


        var isPlaying = true;

        let captureStream = null;

        let lastTimestamp = -1;
        let frames = [];


        FetchTemporaryToken(api_key).then((temp_token) =>
        {
            console.log("temp_token: ", temp_token);
            token = temp_token;
            EyePopSDK.EyePopAPI.FetchPopConfig(pop_endpoint, temp_token)
                .then(response => config = response)
                .then((config) =>
                {

                    config.input = {
                        "name": "file_upload",
                    };

                    config.draw = [
                        { "type": "box", "targets": [ "*" ] },
                        { "type": "pose", "targets": [ "*" ] },
                        { "type": "hand", "targets": [ "*" ] },
                        { "type": "face", "targets": [ "*" ] },
                    ];

                    console.log("EyePopSDK config: ", config);

                    EyePopSDK.EyePopSDK.init(config);
                    EyePopSDK.VideoPlayer.IsTransparentMode = true;

                    document.getElementById("popConfigName").innerHTML = config.name;
                    if (config.name)
                    {
                        loading.classList.add("visually-hidden");
                    } else
                    {
                        loadingText.innerText = "Error: No Pop Config Found, check the config.js file and the dashboard.";
                    }


                });

        })

        togglePlay.addEventListener('click', function (event)
        {
            if (togglePlay.innerHTML == "Play")
            {
                togglePlay.innerHTML = "Pause";
                isPlaying = true;
            } else
            {
                togglePlay.innerHTML = "Play";
                isPlaying = false;
            }
        });

        // a promise to wait indefinitely on when isPlaying is false
        const paused = async () =>
        {
            return new Promise((resolve, reject) =>
            {
                // an interval to check if isPlaying is true
                const interval = setInterval(() =>
                {
                    if (isPlaying)
                    {
                        clearInterval(interval);
                        resolve();
                    }
                }, 100);

            });
        };

        const predictionToJSON = (fileName, jsonData) =>
        {
            return new Promise((resolve, reject) =>
            {
                const jsonString = JSON.stringify(jsonData, null, 2);
                const blob = new Blob([ jsonString ], { type: "application/json" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                document.body.appendChild(a);
                a.style = "display: none";
                a.href = url;
                a.download = fileName + ".json";
                a.addEventListener("click", () =>
                {
                    setTimeout(() =>
                    {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        resolve();
                    }, 100);
                });
                a.click();
            });
        };

        const canvasToPng = async (canvas, fileName) =>
        {
            const frame = canvas.toDataURL("image/png");
            // save frame to a png file named fileName
            const a = document.createElement("a");
            a.href = frame;
            a.download = fileName + ".png";
            a.click();
            a.remove();
        }

        const imageToPng = async (imageObj, fileName) =>
        {
            const frame = imageObj.src;
            // save frame to a png file named fileName
            const a = document.createElement("a");
            a.href = frame;
            a.download = fileName + ".png";
            a.click();
            a.remove();
        }

        const getFrame = async (video, targetCanvas) =>
        {
            // Draw the current video frame to a canvas
            targetCanvas.width = video.videoWidth;
            targetCanvas.height = video.videoHeight;
            let context = targetCanvas.getContext('2d');
            context.drawImage(video, 0, 0, targetCanvas.width, targetCanvas.height);

            // Convert the canvas to a Blob
            const currentVideoFrame = await new Promise(resolve => targetCanvas.toBlob(resolve));
            return currentVideoFrame;
        }

        fileInput.addEventListener('change', async function (event)
        {
            isPlaying = true;

            let file = event.target.files[ 0 ];

            EyePopSDK.VideoPlayer.IsTransparentMode = true;

            mediaName.innerHTML = file.name;

            // Check if the file is a video
            if (file.type.startsWith('video/'))
            {
                isVideo = true;
                // Create a video element
                const video = document.createElement('video');
                video.src = URL.createObjectURL(file);

                // Wait for the video metadata to load
                await new Promise(resolve => video.onloadedmetadata = resolve);


                if (framesToSkip.value != '')
                {
                    skip = Math.floor(framesToSkip.value);
                }

                let frameCount = Math.floor(video.duration);

                // Calculate the number of frames to extract at 30fps
                let skip = 1 / 3;

                console.log("Frame count: ", video);
                console.log("Frame count: ", frameCount);

                for (let j = 0; j < frameCount; j += skip)
                {

                    // Seek to the time of the next frame
                    video.currentTime = j;
                    mediaTime.innerHTML = j.toFixed(2);

                    // Wait for the video to seek to the desired time
                    await new Promise((resolve, reject) =>
                    {
                        video.onseeked = resolve;

                        // Add a timeout to the promise
                        setTimeout(() =>
                        {
                            resolve();
                        }, 100);
                    });

                    // Convert the canvas to a Blob
                    const currentVideoFrame = await getFrame(video, videoCanvas);

                    // Process the frame
                    await processFile(currentVideoFrame);

                    console.log(j, skip, frameCount);

                    if (framesToSkip.value != '')
                    {
                        skip = Math.floor(framesToSkip.value);
                    }

                }

                video.remove();

            }
            createVideoFromImages(frames);
            console.log("finished");

        });


        const drawImage = async (fileData) =>
        {
            return new Promise((resolve, reject) =>
            {
                const reader = new FileReader();
                reader.onload = function (event)
                {
                    image = new Image();
                    image.onload = function ()
                    {
                        mobileCanvasContext.drawImage(image, 0, 0, mobilecanvas.width, mobilecanvas.height);
                        resolve();
                    };
                    image.src = event.target.result;
                };
                reader.readAsDataURL(fileData);
            });
        };

        function captureFrame()
        {
            let dataUrl = mobilecanvas.toDataURL();
            let blob = dataURItoBlob(dataUrl);
            return blob;
        }

        // Step 2: Convert dataURI to Blob
        function dataURItoBlob(dataURI)
        {
            var byteString = atob(dataURI.split(',')[ 1 ]);
            var mimeString = dataURI.split(',')[ 0 ].split(':')[ 1 ].split(';')[ 0 ]
            var ab = new ArrayBuffer(byteString.length);
            var ia = new Uint8Array(ab);
            for (var i = 0; i < byteString.length; i++)
            {
                ia[ i ] = byteString.charCodeAt(i);
            }
            return new Blob([ ab ], { type: mimeString });
        }


        async function processFile(file)
        {

            // loadingText.innerText = "Processing...";
            // loading.classList.remove("visually-hidden");
            EyePopSDK.EyePopAPI.GetJSONFromEyePop_file(file);

            // isPlaying = false;

            // draw the file on the canvas
            await drawImage(file);

            frames.push(captureFrame())

        }

    </script>
</body>

</html>
