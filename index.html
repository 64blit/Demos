<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Basic Test</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="overflow-hidden d-flex bg-black flex-row justify-content-center gap-5"
    style="width: 100vw; height: 100vh; scale: .9;">

    <!-- A spinning loading animation -->
    <div id="loading" class="position-absolute w-100 h-100 d-flex align-items-center justify-content-center bg-black"
        style="z-index: 1000;">
        <div class="spinner-border text-light align-self-center" role="status">

            <span class="visually-hidden">Loading...</span>

        </div>
    </div>

    <header id="canvasParent" class="position-absolute w-100 mx-auto z-3" style="top: -4rem;">
        <div class="container-fluid d-flex align-items-center justify-content-between text-center">
            <a href="1_upload_image.html"><img src="css/images/eyepop-logo.svg" alt="EyePop.ai Logo" class="p-2"
                    style="height: 70px;"></a>
            <h1 class="p-2 text-center text-white">Batch Image / Video Tester</h1>
            <h6 id="popConfigName" class="text-center text-white">test</h6>
        </div>
    </header>


    <div class="d-flex align-self-center flex-column justify-content-center">

        <div>
            <canvas id="rendercanvas" class="bg-success object-fit-contain" width="640px" height="480px"></canvas>
        </div>

        <div>
            <canvas id="mobilecanvas" class="bg-info object-fit-contain" width="640px" height="480px"></canvas>
        </div>

    </div>

    <div class="d-flex flex-column justify-content-center gap-3 w-50 ">
        <!-- FORM UPLOAD ELEMENT: Centered, Full Width Row -->
        <div class="container-fluid z-3 bg-black rounded-2">
            <div class="row justify-content-center">
                <div id="drop-area" class="col-12">

                    <form>
                        <input type="file" class="form-control" id="file_upload" webkitdirectory
                            accept="application/octet-stream">
                    </form>

                    <form class="d-flex">
                        <input type="text" class="form-control" placeholder="MP4 URL" aria-label="MP4 URL"
                            aria-describedby="basic-addon2" id="txtUrl">
                        <button class="btn bg-black text-white" type="button" id="btnPost">Post</button>
                    </form>

                    <form class="col-12">

                        <input type="number" class="form-control" placeholder="Frames to skip"
                            aria-label="Frames to skip" aria-describedby="basic-addon2" id="framesToSkip">

                        <input type="text" class="form-control" placeholder="Indices to play (1,2,3,5,8)"
                            aria-label="Indices to play (1,2,3,5,8)" aria-describedby="basic-addon2" id="videosToPlay">

                        <button id="togglePlay" class="btn btn-primary" type="button">Pause</button>
                        <button id="saveButton" class="btn btn-primary" type="button">Save</button>

                    </form>

                </div>
            </div>
        </div>

        <div class="d-flex gap-1 overflow-auto">
            <h3 class="text-info">name: </h3>
            <h3 id="mediaName" class="text-white">Video</h3>
            <h3 class="text-info">index: </h3>
            <h3 id="mediaIndex" class="text-white">0</h3>
            <h3 class="text-info">time: </h3>
            <h3 id="mediaTime" class="text-white">0</h3>
        </div>

        <video id="myLocalVideo" playsinline controls muted style="width:1px;height:1px;"></video>
        <video id="videoCapture" class="position-absolute z-n1" style="width: 1px; height: 1px;"></video>

        <div class="d-flex justify-content-center">
            <json-viewer id="jsonDisplay" class="align-self-center"
                style="width: 100%; height: 40rem; overflow: auto;"></json-viewer>
        </div>

    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three/build/three.module.js",
                "three/addons/": "https://unpkg.com/three/examples/jsm/"
            }
        }
    </script>

    <script src="https://unpkg.com/@alenaksu/json-viewer/dist/json-viewer.bundle.js"></script>


    <script src="https://cdn.jsdelivr.net/npm/@eyepop.ai/javascript-sdk"></script>

    <script type="module">

        import ThirdEyePop from "../utils/ThirdEyePop.js";

        const pop_endpoint = 'https://staging-api.eyepop.ai/api/v1/user/pops/513/config';
        const token = 'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InZUdzF6bi02cjFPcXg0NmNxRl9PMiJ9.eyJlbWFpbCI6ImVkbXVuZGRhb0BnbWFpbC5jb20iLCJodHRwczovL2NsYWltcy5leWVwb3AuYWkvZ3JhbnRzIjpbeyJwZXJtaXNzaW9uIjoiYWNjZXNzOmluZmVyZW5jZS1hcGkiLCJ0YXJnZXQiOiJ1c2VyOmF1dGgwfDY1YWVhYmExNTBkMzk1YTNjODA2OGVlZSJ9XSwiaXNzIjoiaHR0cHM6Ly9kZXYtZXllcG9wLnVzLmF1dGgwLmNvbS8iLCJzdWIiOiJhdXRoMHw2NWFlYWJhMTUwZDM5NWEzYzgwNjhlZWUiLCJhdWQiOlsiaHR0cHM6Ly9kZXYtYXBwLmV5ZXBvcC5haSIsImh0dHBzOi8vZGV2LWV5ZXBvcC51cy5hdXRoMC5jb20vdXNlcmluZm8iXSwiaWF0IjoxNzA2MTQyMDc2LCJleHAiOjE3MDYyMjg0NzYsImF6cCI6IklVdDBwczJtYVdaVWRFbUVPUFJhUEpLdmtRVHM2WVVFIiwic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBlbWFpbCIsInBlcm1pc3Npb25zIjpbXX0.EoOlxPgrv-jthnkGopRB4XAwky5Cx5rAH_jYaDTHdTHjbxx4jPWChS9Eu3S6WvQ96TIXbFEvLyOgdoJCj8nubQHGD9McTPvK1Alht0HF9oKtSMd0UmwzNih7UnrVxWEJ0hM3UY5DJqns5x0cAJXGQJVTJ1qIhHEIRlnNi52_o13bjr3M_xyB0hv3x302tPmQUVBjJlLBTPpr5kCumPhocbZtOpiL4s4Z62qxoHnn5Uu57xJxjjoB1id8L_c9SvgJKjKeAJKb8IXSnSrK5S4FXF2D_GD42Ot8U2GOUNv5b_vST9pWrBOdnxTRykkOOBvi-V0n1hrvv_SsZsRfMHYHzg';
        var config = {};

        var fileInput = document.getElementById('file_upload');
        const postButton = document.getElementById('btnPost');
        const loading = document.getElementById('loading');

        const captureCanvas = document.createElement("canvas");
        const captureContext = captureCanvas.getContext("2d");
        const captureVideo = document.getElementById("videoCapture");

        const renderCanvas = document.getElementById("rendercanvas");
        const mobilecanvas = document.getElementById("mobilecanvas");
        const mobileCanvasContext = mobilecanvas.getContext("2d");

        const framesToSkip = document.getElementById("framesToSkip");
        const videosToPlay = document.getElementById("videosToPlay");
        const playPause = document.getElementById("playPause");

        const mediaName = document.getElementById("mediaName");
        const mediaIndex = document.getElementById("mediaIndex");
        const mediaTime = document.getElementById("mediaTime");

        const togglePlay = document.getElementById("togglePlay");
        const saveButton = document.getElementById("saveButton");

        const jsonText = document.getElementById("jsonDisplay");

        var isPlaying = true;

        let captureStream = null;

        let lastTimestamp = -1;


        EyePopSDK.EyePopAPI.FetchPopConfig(pop_endpoint, token).then(response => config = response).then(() =>
        {
            document.getElementById("popConfigName").innerHTML = config.name;
            if (config.name)
            {
                loading.remove();
            }

        });

        saveButton.addEventListener('click', function (event)
        {
            capture();
        });


        const thirdEyePop = new ThirdEyePop(
            {
                canvas: renderCanvas,
                // videoUrl: "webcam",
                frameBufferSize: 1,
                DEBUG: true,
                drawParams: {
                    bgCanvas: mobilecanvas,
                    showHeatmap: false,
                    showFace: true,
                    showHands: true,
                    showPoint: true,
                    showPath: false,
                    showBounds: true,
                    showTraceId: true,
                    showPose: true,
                    showGammaCorrection: false,
                }
            });

        thirdEyePop.setup();

        togglePlay.addEventListener('click', function (event)
        {
            if (togglePlay.innerHTML == "Play")
            {
                togglePlay.innerHTML = "Pause";
                isPlaying = true;
            } else
            {
                togglePlay.innerHTML = "Play";
                isPlaying = false;
            }
        });

        // on space toggle play pause
        document.addEventListener('keydown', function (event)
        {
            if (event.code == "Space")
            {
                if (togglePlay.innerHTML == "Play")
                {
                    togglePlay.innerHTML = "Pause";
                    isPlaying = true;
                } else
                {
                    togglePlay.innerHTML = "Play";
                    isPlaying = false;
                }
            }

            // if s is pressed, fire the capture function
            if (event.code == "KeyS")
            {
                capture();
            }
        });

        // a promise to wait indefinitely on when isPlaying is false
        const paused = async () =>
        {
            return new Promise((resolve, reject) =>
            {
                // an interval to check if isPlaying is true
                const interval = setInterval(() =>
                {
                    if (isPlaying)
                    {
                        clearInterval(interval);
                        resolve();
                    }
                }, 100);

            });
        };

        const saveJson = (fileName, jsonData) =>
        {
            return new Promise((resolve, reject) =>
            {
                const jsonString = JSON.stringify(jsonData);
                const blob = new Blob([ jsonString ], { type: "application/json" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                document.body.appendChild(a);
                a.style = "display: none";
                a.href = url;
                a.download = fileName + ".json";
                a.addEventListener("click", () =>
                {
                    setTimeout(() =>
                    {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        resolve();
                    }, 100);
                });
                a.click();
            });
        };

        const capture = async (fileName = "ep_test") =>
        {
            try
            {
                if (!captureStream)
                {
                    captureStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                    captureVideo.srcObject = captureStream;
                    captureVideo.play();
                }

                captureCanvas.width = captureVideo.videoWidth;
                captureCanvas.height = captureVideo.videoHeight;
                captureContext.drawImage(captureVideo, 0, 0, captureCanvas.width, captureCanvas.height);

                const frame = captureCanvas.toDataURL("image/png");

                // save frame to a png file named fileName
                const a = document.createElement("a");
                document.body.appendChild(a);
                a.style = "display: none";
                a.href = frame;
                a.download = fileName + ".png";
                a.click();
                document.body.removeChild(a);

            } catch (err)
            {
                console.error("Error capturing screen: " + err);
            }
        };

        async function GetJSONFromEyePop_file(file)
        {
            let formData = new FormData()
            formData.append('file', file)

            let response = await fetch(config.url + '/pipelines/' + config.pipeline_id + '/source?mode=preempt&processing=sync', {
                method: 'POST',
                headers: {
                    'accept': 'application/json',
                    'authorization': 'Bearer ' + token
                },
                body: formData
            }).catch(error => console.error('The party\'s over, there was an error:', error));

            let data = await response.json();

            return data;
        }


        // create an interval to set the json text area to the json data
        setInterval(() =>
        {

            if (!EyePopSDK.EyePopAPI.instance) return;
            if (!EyePopSDK.EyePopAPI.instance.lastmsg) return;

            // only create a new json viewer if the lastmsg content is different, doing a deep comparison
            if (JSON.stringify(EyePopSDK.EyePopAPI.instance.lastmsg) != JSON.stringify(thirdEyePop.getPredictionData()))
            {
                jsonText.data = EyePopSDK.EyePopAPI.instance.lastmsg;
            }

            thirdEyePop.pushPredictionData(EyePopSDK.EyePopAPI.instance.lastmsg);

        }, 100);

        const draw = async (fileData) =>
        {
            return new Promise((resolve, reject) =>
            {
                const reader = new FileReader();
                reader.onload = function (event)
                {
                    const img = new Image();
                    img.onload = function ()
                    {
                        mobileCanvasContext.drawImage(img, 0, 0, mobilecanvas.width, mobilecanvas.height);
                        resolve();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(fileData);
            });
        };

        postButton.addEventListener('click', function (event)
        {
            let url = document.getElementById("txtUrl").value;

            console.log("Posted URL: ", url);

            const popConfigFetch = EyePopSDK.EyePopAPI.FetchPopConfig(pop_endpoint, token);

            config.Draw = [
                { "Type": "box", "Targets": [ "*" ] },
                { "Type": "pose", "Targets": [ "*" ] },
                { "Type": "hand", "Targets": [ "*" ] },
                { "Type": "face", "Targets": [ "*" ] },
            ]

            if (!url)
            { return; }

            popConfigFetch.then((response) =>
            {
                config = response;
                config.Input = {
                    "name": "url",
                    "url": url
                };

                console.log("EyePopSDK config: ", config);

                EyePopSDK.EyePopSDK.init(config);

                EyePopSDK.EyePopAPI.instance.OnDrawFrame = function (data)
                {
                    console.log("EyePopSDK data: ", data);
                }

            });

        });


        fileInput.addEventListener('change', async function (event)
        {
            let framesToSkipArray = null;

            // get the video indexes to play
            if (framesToSkip.value != '')
            {
                // parse the array of integers in frames to skip
                framesToSkipArray = framesToSkip.value.split(",").map(function (item)
                {
                    return parseInt(item, 10);
                });
            }

            // if the target is a directory loop over all files and run this one by one
            for (let i = 0; i < event.target.files.length; i++)
            {
                let file = event.target.files[ i ];
                // thirdEyePop.reset();

                // wait until isPlaying is true
                await paused();

                // only play the videos in the videosToPlay array
                if (framesToSkipArray && !(i in framesToSkipArray))
                {
                    continue;
                }

                mediaName.innerHTML = file.name;
                mediaIndex.innerHTML = i;
                mediaTime.innerHTML = 0;

                // Check if the file is a video
                if (file.type.startsWith('video/'))
                {
                    // Create a video element
                    let video = document.createElement('video');
                    video.src = URL.createObjectURL(file);

                    // Wait for the video metadata to load
                    await new Promise(resolve => video.onloadedmetadata = resolve);

                    // Calculate the number of frames to extract
                    let frameInterval = 5;

                    if (framesToSkip.value != '')
                    {
                        frameInterval = framesToSkip.value; // Change this to your desired frame interval
                    }

                    let frameCount = Math.floor(video.duration / frameInterval);

                    for (let j = 0; j < frameCount; j++)
                    {


                        // Seek to the time of the next frame
                        video.currentTime = j * frameInterval;
                        mediaTime.innerHTML = video.currentTime;

                        // Wait for the video to seek to the desired time
                        await new Promise((resolve, reject) =>
                        {
                            video.onseeked = resolve;

                            // Add a timeout to the promise
                            setTimeout(() =>
                            {
                                console.warn('Seek operation took too long, continuing anyway');
                                resolve();
                            }, 250);
                        });


                        // Draw the current video frame to a canvas
                        let canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        let context = canvas.getContext('2d');
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);

                        // Convert the canvas to a Blob
                        let frameBlob = await new Promise(resolve => canvas.toBlob(resolve));

                        // Process the frame
                        await processFile(frameBlob);

                        video.remove();

                    }
                } else
                {
                    // If the file is not a video, process it as before
                    await processFile(file);
                }
            }
        });

        async function processFile(file)
        {
            const popConfigFetch = EyePopSDK.EyePopAPI.FetchPopConfig(pop_endpoint, token);

            let result = await popConfigFetch.then((response) =>
            {
                config = response;

                config.Input = {
                    "name": "file_upload",
                };

                config.Draw = [
                    { "Type": "box", "Targets": [ "*" ] },
                    { "Type": "pose", "Targets": [ "*" ] },
                    { "Type": "hand", "Targets": [ "*" ] },
                    { "Type": "face", "Targets": [ "*" ] },
                ];

                console.log("EyePopSDK config: ", config);

                EyePopSDK.EyePopSDK.init(config);

                EyePopSDK.EyePopAPI.GetJSONFromEyePop_file(file);
            });

            // draw the file on the canvas
            await draw(file);

            togglePlay.click();

            await paused();

        }

    </script>
</body>

</html>
